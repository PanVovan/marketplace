// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.13.0
// source: order.sql

package sqlc

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders(id, name, email, address, amount, status, phone, comment, user_id) 
VALUES (uuid_generate_v4(), $1, $2, $3, $4, $5, $6, $7, $8) RETURNING id
`

type CreateOrderParams struct {
	Name    string         `db:"name"`
	Email   string         `db:"email"`
	Address string         `db:"address"`
	Amount  int32          `db:"amount"`
	Status  int32          `db:"status"`
	Phone   string         `db:"phone"`
	Comment sql.NullString `db:"comment"`
	UserID  uuid.NullUUID  `db:"user_id"`
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, createOrder,
		arg.Name,
		arg.Email,
		arg.Address,
		arg.Amount,
		arg.Status,
		arg.Phone,
		arg.Comment,
		arg.UserID,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const deleteOrder = `-- name: DeleteOrder :exec
DELETE FROM orders WHERE id = $1
`

func (q *Queries) DeleteOrder(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteOrder, id)
	return err
}

const getOrderByID = `-- name: GetOrderByID :one
SELECT id, name, email, address, amount, status, phone, comment, user_id FROM orders  WHERE id = $1
`

func (q *Queries) GetOrderByID(ctx context.Context, id uuid.UUID) (Order, error) {
	row := q.db.QueryRowContext(ctx, getOrderByID, id)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Address,
		&i.Amount,
		&i.Status,
		&i.Phone,
		&i.Comment,
		&i.UserID,
	)
	return i, err
}

const getOrders = `-- name: GetOrders :many
SELECT id, name, email, address, amount, status, phone, comment, user_id FROM orders  LIMIT $1 OFFSET $2
`

type GetOrdersParams struct {
	Limit  int32 `db:"limit"`
	Offset int32 `db:"offset"`
}

func (q *Queries) GetOrders(ctx context.Context, arg GetOrdersParams) ([]Order, error) {
	rows, err := q.db.QueryContext(ctx, getOrders, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Address,
			&i.Amount,
			&i.Status,
			&i.Phone,
			&i.Comment,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrdersByEmail = `-- name: GetOrdersByEmail :many
SELECT id, name, email, address, amount, status, phone, comment, user_id FROM orders  WHERE email = $1 LIMIT $2 OFFSET $3
`

type GetOrdersByEmailParams struct {
	Email  string `db:"email"`
	Limit  int32  `db:"limit"`
	Offset int32  `db:"offset"`
}

func (q *Queries) GetOrdersByEmail(ctx context.Context, arg GetOrdersByEmailParams) ([]Order, error) {
	rows, err := q.db.QueryContext(ctx, getOrdersByEmail, arg.Email, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Address,
			&i.Amount,
			&i.Status,
			&i.Phone,
			&i.Comment,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrdersByPhone = `-- name: GetOrdersByPhone :many
SELECT id, name, email, address, amount, status, phone, comment, user_id FROM orders  WHERE phone = $1 LIMIT $2 OFFSET $3
`

type GetOrdersByPhoneParams struct {
	Phone  string `db:"phone"`
	Limit  int32  `db:"limit"`
	Offset int32  `db:"offset"`
}

func (q *Queries) GetOrdersByPhone(ctx context.Context, arg GetOrdersByPhoneParams) ([]Order, error) {
	rows, err := q.db.QueryContext(ctx, getOrdersByPhone, arg.Phone, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Address,
			&i.Amount,
			&i.Status,
			&i.Phone,
			&i.Comment,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrdersByStatus = `-- name: GetOrdersByStatus :many
SELECT id, name, email, address, amount, status, phone, comment, user_id FROM orders  WHERE status = $1 LIMIT $2 OFFSET $3
`

type GetOrdersByStatusParams struct {
	Status int32 `db:"status"`
	Limit  int32 `db:"limit"`
	Offset int32 `db:"offset"`
}

func (q *Queries) GetOrdersByStatus(ctx context.Context, arg GetOrdersByStatusParams) ([]Order, error) {
	rows, err := q.db.QueryContext(ctx, getOrdersByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Address,
			&i.Amount,
			&i.Status,
			&i.Phone,
			&i.Comment,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrdersByUserID = `-- name: GetOrdersByUserID :many
SELECT id, name, email, address, amount, status, phone, comment, user_id FROM orders  WHERE user_id = $1 LIMIT $2 OFFSET $3
`

type GetOrdersByUserIDParams struct {
	UserID uuid.NullUUID `db:"user_id"`
	Limit  int32         `db:"limit"`
	Offset int32         `db:"offset"`
}

func (q *Queries) GetOrdersByUserID(ctx context.Context, arg GetOrdersByUserIDParams) ([]Order, error) {
	rows, err := q.db.QueryContext(ctx, getOrdersByUserID, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Address,
			&i.Amount,
			&i.Status,
			&i.Phone,
			&i.Comment,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
